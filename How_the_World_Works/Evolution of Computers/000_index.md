# How Computers Work

---

## Foundations Overview

**01 - Learning from First Principles**  
Context, motivation, and core questions

**02 - Defining a Computer**  
Concepts and the critical role of software instructions

**03 - Guide Structure and Roadmap**  
Overview of topics from atoms to high-level languages

---

## History of Early Computation

**04 - Ancient Computational Tools**  
Abacus, Antikythera mechanism, Slide Rule

**05 - Mechanization of Logic**  
Jacquard Loom and Punch Card systems

**06 - Automation and Societal Response**  
The Luddite movement and AI comparisons

**07 - Babbage’s Computing Machines**  
Difference Engine and Analytical Engine

---

## Birth of Modern Computers

**08 - Konrad Zuse’s Z3 (1941)**  
The first programmable electromechanical computer

**09 - Harvard Mark I and Grace Hopper**  
Innovations in electromechanical design

**10 - Atanasoff-Berry Computer (ABC)**  
Binary digital computation beginnings

---

## Rise of Electronic Computing

**11 - Colossus and WWII Cryptography**  
Breaking the Enigma code

**12 - ENIAC’s Breakthrough**  
Vacuum tubes and electronic speed

**13 - EDSAC and the Stored-Program Concept**  
Transition to transistorized logic

---

## Core Computer Architecture

**14 - CPU, ALU, and Control Flow**  
Central execution and logic units

**15 - Clock Speed and Frequency**  
Measuring performance in Hz

**16 - The Von Neumann Architecture**  
Design fundamentals and the bottleneck challenge

---

## Memory and Peripheral Devices

**17 - RAM and Volatility**  
Fast, temporary memory explained

**18 - Storage and I/O Systems**  
Drives, ports, buses, and modern interfaces

---

## Understanding Digital Units

**19 - Digital Storage Units**  
From bits to terabytes

**20 - RAM vs Permanent Storage**  
Purpose and differences

**21 - Memory Hierarchy and Cache**  
Balancing speed and access

---

## Hardware Logic and Scaling

**22 - Transistors and Logic Gates**  
Binary computation at the silicon level

**23 - Moore’s Law and Scaling Trends**  
Historical chip growth and future limits

**24 - Heat, Power, and Cost Tradeoffs**  
Energy efficiency and thermal design

---

## Low-Level Programming Concepts

**25 - Machine Language and Assembly**  
Raw instructions and memory operations

**26 - Assemblers and Instruction Sets**  
Converting human-readable to machine code

---

## High-Level Language Evolution

**27 - History of Programming Languages**  
Milestones from FORTRAN to modern languages

**28 - Paradigms of Programming**  
Procedural, object-oriented, functional, logic

---

## Software Execution and Beyond

**29 - Compilers vs Interpreters**  
Understanding translation of code

**30 - Practice and Further Exploration**  
Exercises, projects, and recommended reading

---
